
# 会话与状态管理

<cite>
**本文档中引用的文件**   
- [agent.py](file://libs/agno/agno/session/agent.py)
- [team.py](file://libs/agno/agno/session/team.py)
- [workflow.py](file://libs/agno/agno/session/workflow.py)
- [summary.py](file://libs/agno/agno/session/summary.py)
- [01_persistent_session.py](file://cookbook/agents/session/01_persistent_session.py)
- [02_persistent_session_history.py](file://cookbook/agents/session/02_persistent_session_history.py)
- [03_session_summary.py](file://cookbook/agents/session/03_session_summary.py)
- [04_session_summary_references.py](file://cookbook/agents/session/04_session_summary_references.py)
- [05_chat_history.py](file://cookbook/agents/session/05_chat_history.py)
- [06_rename_session.py](file://cookbook/agents/session/06_rename_session.py)
- [07_in_memory_db.py](file://cookbook/agents/session/07_in_memory_db.py)
- [08_cache_session.py](file://cookbook/agents/session/08_cache_session.py)
- [01_persistent_session_storage.py](file://cookbook/db/01_persistent_session_storage.py)
- [02_session_summary.py](file://cookbook/db/02_session_summary.py)
- [03_chat_history.py](file://cookbook/db/03_chat_history.py)
- [README.md](file://cookbook/db/README.md)
</cite>

## 目录
1. [简介](#简介)
2. [会话对象结构](#会话对象结构)
3. [会话创建与恢复](#会话创建与恢复)
4. [会话持久化机制](#会话持久化机制)
5. [会话状态管理](#会话状态管理)
6. [会话摘要机制](#会话摘要机制)
7. [对话历史管理](#对话历史管理)
8. [会话生命周期管理](#会话生命周期管理)
9. [会话数据访问与修改](#会话数据访问与修改)
10. [会话追踪与标识](#会话追踪与标识)

## 简介
Agno 智能体系统提供了一套完整的会话与状态管理机制，用于在多次交互中保持上下文一致性。会话系统通过 `Session` 对象封装对话历史、持久化状态和元数据，支持智能体、团队和工作流三种场景。该系统实现了会话的创建、恢复、持久化和摘要功能，确保智能体能够在长时间对话中保持连贯性和上下文感知能力。

**会话与状态管理的核心特性包括**：
- 会话对象封装对话历史、状态和元数据
- 通过 `session_id` 进行会话追踪
- 支持多种持久化存储后端
- 会话摘要生成以管理长对话
- 会话数据生命周期管理

## 会话对象结构

Agno 系统中的会话对象是核心的数据结构，用于封装对话的完整上下文。系统定义了三种主要的会话类型：`AgentSession`（智能体会话）、`TeamSession`（团队会话）和 `WorkflowSession`（工作流会话），它们都继承自统一的 `Session` 类型。

```mermaid
classDiagram
class AgentSession {
+string session_id
+string? agent_id
+string? user_id
+string? workflow_id
+string? team_id
+Dict[string, any]? session_data
+Dict[string, any]? metadata
+Dict[string, any]? agent_data
+List[RunOutput]? runs
+SessionSummary? summary
+int? created_at
+int? updated_at
+to_dict() Dict[string, any]
+from_dict(data) AgentSession
+upsert_run(run) void
+get_run(run_id) RunOutput?
+get_messages_from_last_n_runs(...) List[Message]
+get_tool_calls(...) List[Dict[string, any]]
+get_messages_for_session(...) List[Message]
+get_session_summary() SessionSummary?
+get_chat_history() List[Message]
}
class TeamSession {
+string session_id
+string? team_id
+string? user_id
+string? workflow_id
+Dict[string, any]? team_data
+Dict[string, any]? session_data
+Dict[string, any]? metadata
+List[Union[TeamRunOutput, RunOutput]]? runs
+SessionSummary? summary
+int? created_at
+int? updated_at
+to_dict() Dict[string, any]
+from_dict(data) TeamSession
+get_run(run_id) Union[TeamRunOutput, RunOutput]?
+upsert_run(run_response) void
+get_messages_from_last_n_runs(...) List[Message]
+get_tool_calls(...) List[Dict[string, any]]
+get_messages_for_session(...) List[Message]
+get_session_summary() SessionSummary?
+get_chat_history() List[Message]
}
class WorkflowSession {
+string session_id
+string? user_id
+string? workflow_id
+string? workflow_name
+List[WorkflowRunOutput]? runs
+Dict[string, any]? session_data
+Dict[string, any]? workflow_data
+Dict[string, any]? metadata
+int? created_at
+int? updated_at
+__post_init__() void
+get_run(run_id) WorkflowRunOutput?
+upsert_run(run) void
+to_dict() Dict[string, any]
+from_dict(data) WorkflowSession?
}
class SessionSummary {
+string summary
+List[string]? topics
+datetime? updated_at
+to_dict() Dict[string, any]
+from_dict(data) SessionSummary
}
AgentSession --> SessionSummary : "包含"
TeamSession --> SessionSummary : "包含"
WorkflowSession --> SessionSummary : "包含"
```

**Diagram sources**
- [agent.py](file://libs/agno/agno/session/agent.py#L25-L247)
- [team.py](file://libs/agno/agno/session/team.py#L25-L266)
- [workflow.py](file://libs/agno/agno/session/workflow.py#L10-L137)
- [summary.py](file://libs/agno/agno/session/summary.py#L15-L45)

**会话对象的主要组成部分包括**：

### 核心标识字段
- `session_id`: 会话的唯一标识符，用于会话追踪和恢复
- `agent_id`/`team_id`/`workflow_id`: 关联的智能体、团队或工作流ID
- `user_id`: 与会话交互的用户ID

### 状态与数据字段
- `session_data`: 存储会话相关的数据，如会话名称、状态、媒体文件等
- `metadata`: 存储与会话相关的元数据
- `agent_data`/`team_data`/`workflow_data`: 存储关联实体的数据

### 历史记录字段
- `runs`: 存储会话中的所有运行记录（RunOutput）
- `summary`: 存储会话摘要信息

### 时间戳字段
- `created_at`: 会话创建时间（Unix时间戳）
- `updated_at`: 会话最后更新时间（Unix时间戳）

**Section sources**
- [agent.py](file://libs/agno/agno/session/agent.py#L25-L247)
- [team.py](file://libs/agno/agno/session/team.py#L25-L266)
- [workflow.py](file://libs/agno/agno/session/workflow.py#L10-L137)

## 会话创建与恢复

Agno 系统提供了灵活的会话创建与恢复机制，支持在智能体初始化时启用会话记忆，并通过 `session_id` 进行会话追踪。

### 会话创建
会话创建通常在智能体初始化时完成，通过配置数据库连接来启用会话持久化：

```python
from agno.agent import Agent
from agno.db.postgres import PostgresDb

# 创建数据库连接
db = PostgresDb(db_url="postgresql+psycopg://user:password@localhost:5432/dbname")

# 创建智能体并启用会话记忆
agent = Agent(
    db=db,
    add_history_to_context=True,
)
```

当智能体首次与用户交互时，系统会自动创建一个新的会话对象，并分配唯一的 `session_id`。

### 会话恢复
会话恢复通过 `session_id` 实现，允许在后续交互中恢复之前的上下文：

```python
# 使用现有的 session_id 恢复会话
response = agent.run(
    message="Hello again!",
    session_id="existing_session_id_123"
)
```

系统会根据提供的 `session_id` 从数据库中检索会话数据，包括对话历史、状态和元数据，从而恢复完整的上下文。

### 会话重命名
系统支持会话重命名功能，允许用户为会话设置更具描述性的名称：

```python
# 更新会话数据以重命名会话
session_data = {"session_name": "Customer Support Chat"}
response = agent.run(
    message="How can I help you today?",
    session_id="session_123",
    session_data=session_data
)
```

**Section sources**
- [01_persistent_session.py](file://cookbook/agents/session/01_persistent_session.py)
- [06_rename_session.py](file://cookbook/agents/session/06_rename_session.py)
- [01_persistent_session_storage.py](file://cookbook/db/01_persistent_session_storage.py)

## 会话持久化机制

Agno 系统支持多种持久化存储后端，确保会话数据在应用重启后仍然可用。

### 支持的数据库
系统支持以下数据库作为会话存储后端：
- PostgreSQL
- SQLite
- MongoDB
- MySQL
- Redis
- SingleStore
- Google Cloud Firestore
- AWS DynamoDB
- JSON 文件存储
- 内存存储（可选持久化钩子）

### 持久化配置
持久化配置通过在智能体初始化时提供数据库实例完成：

```python
from agno.agent import Agent
from agno.db.redis import RedisDb

# 配置 Redis 作为会话存储
db = RedisDb(host="localhost", port=6379, db=0)

agent = Agent(
    name="Persistent Agent",
    model="gpt-4",
    db=db,
    add_history_to_context=True,
)
```

### 持久化流程
会话持久化流程如下：
1. 智能体接收到用户输入
2. 系统检查是否存在 `session_id`
3. 如果存在，从数据库加载会话数据
4. 执行智能体逻辑并生成响应
5. 更新会话对象（添加新的运行记录）
6. 将更新后的会话对象保存回数据库

```mermaid
sequenceDiagram
participant User as "用户"
participant Agent as "智能体"
participant DB as "数据库"
User->>Agent : 发送消息
Agent->>DB : 查询 session_id 对应的会话
DB-->>Agent : 返回会话数据
Agent->>Agent : 处理消息并生成响应
Agent->>Agent : 更新会话对象
Agent->>DB : 保存更新后的会话
DB-->>Agent : 确认保存成功
Agent->>User : 返回响应
Note over User,DB : 会话数据在每次交互后持久化
```

**Diagram sources**
- [01_persistent_session_storage.py](file://cookbook/db/01_persistent_session_storage.py)
- [07_in_memory_db.py](file://cookbook/agents/session/07_in_memory_db.py)
- [08_cache_session.py](file://cookbook/agents/session/08_cache_session.py)

**Section sources**
- [01_persistent_session_storage.py](file://cookbook/db/01_persistent_session_storage.py)
- [07_in_memory_db.py](file://cookbook/agents/session/07_in_memory_db.py)
- [08_cache_session.py](file://cookbook/agents/session/08_cache_session.py)

## 会话状态管理

会话状态管理允许在会话过程中存储和访问自定义状态数据，支持复杂的交互场景。

### 状态数据存储
会话状态通过 `session_data` 字段进行管理，可以存储任意 JSON 可序列化的数据：

```python
# 在运行时更新会话状态
session_data = {
    "user_preferences": {
        "language": "zh-CN",
        "theme": "dark"
    },
    "conversation_stage": "greeting",
    "order_id": "ORD-12345"
}

response = agent.run(
    message="I want to change my order",
    session_id="session_123",
    session_data=session_data
)
```

### 状态访问
在智能体逻辑中，可以通过会话对象访问当前状态：

```python
def get_user_preferences(session_id: str):
    # 从数据库获取会话对象
    session = db.get_session(session_id)
    if session and session.session_data:
        return session.session_data.get("user_preferences", {})
    return {}
```

### 状态更新策略
系统支持多种状态更新策略：
- **覆盖更新**：完全替换现有的 `session_data`
- **增量更新**：只更新指定的字段，保留其他字段不变
- **条件更新**：基于当前状态的条件进行更新

```python
# 增量更新会话状态
current_session_data = agent.get_session_data(session_id)
updated_data = {**current_session_data, "last_interaction": "2024-01-01"}
agent.update_session_data(session_id, updated_data)
```

**Section sources**
- [agent.py](file://libs/agno/agno/session/agent.py#L25-L247)
- [team.py](file://libs/agno/agno/session/team.py#L25-L266)
- [03_session_summary.py](file://cookbook/agents/session/03_session_summary.py)

## 会话摘要机制

会话摘要机制用于管理长对话，通过生成简洁的摘要来避免上下文过长的问题。

### 摘要生成
系统使用专门的模型生成会话摘要，提取对话的关键信息：

```mermaid
flowchart TD
Start([开始摘要生成]) --> PrepareMessages["准备摘要消息"]
PrepareMessages --> GetConversation["获取完整对话历史"]
GetConversation --> CreatePrompt["创建摘要提示"]
CreatePrompt --> CallModel["调用摘要模型"]
CallModel --> ProcessResponse["处理模型响应"]
ProcessResponse --> ExtractSummary["提取摘要内容"]
ExtractSummary --> ExtractTopics["提取讨论主题"]
ExtractTopics --> UpdateTimestamp["更新时间戳"]
UpdateTimestamp --> StoreSummary["存储摘要到会话"]
StoreSummary --> End([摘要生成完成])
```

**Diagram sources**
- [summary.py](file://libs/agno/agno/session/summary.py#L50-L225)

### 摘要模型配置
摘要生成使用专门配置的模型，支持结构化输出：

```python
from agno.models.openai import OpenAIModel
from agno.session.summary import SessionSummaryManager

# 配置摘要模型
summary_model = OpenAIModel(model="gpt-3.5-turbo")

# 创建摘要管理器
summary_manager = SessionSummaryManager(
    model=summary_model,
    session_summary_prompt="请总结以下对话..."
)
```

### 摘要内容结构
生成的会话摘要包含以下信息：
- **summary**：对话的简洁总结，聚焦重要信息
- **topics**：讨论的主题列表
- **updated_at**：摘要更新时间

```python
class SessionSummaryResponse(BaseModel):
    summary: str = Field(
        ...,
        description="会话的摘要。保持简洁，只关注重要信息。不要编造内容。"
    )
    topics: Optional[List[str]] = Field(None, description="会话中讨论的主题。")
```

### 摘要触发机制
摘要生成可以在以下情况下触发：
- 会话达到一定长度（如消息数量或字符数）
- 特定时间间隔后
- 手动触发
- 会话结束时

```python
# 手动创建会话摘要
summary = summary_manager.create_session_summary(session)
```

**Section sources**
- [summary.py](file://libs/agno/agno/session/summary.py#L15-L225)
- [03_session_summary.py](file://cookbook/agents/session/03_session_summary.py)
- [02_session_summary.py](file://cookbook/db/02_session_summary.py)

## 对话历史管理

对话历史管理是会话系统的核心功能，确保智能体能够访问和利用之前的交互记录。

### 历史记录结构
对话历史存储在会话对象的 `runs` 字段中，每个 `RunOutput` 包含一次交互的完整记录：

```python
@dataclass
class RunOutput:
    run_id: str
    messages: List[Message]
    status: RunStatus
    metrics: Optional[RunMetrics] = None
    parent_run_id: Optional[str] = None
```

### 历史访问方法
系统提供了多种方法来访问对话历史：

#### 获取最后N次运行的消息
```python
def get_messages_from_last_n_runs(
    self,
    last_n: Optional[int] = None,
    skip_role: Optional[str] = None,
    skip_status: Optional[List[RunStatus]] = None,
    skip_history_messages: bool = True,
) -> List[Message]:
    """
    返回最后N次运行中的消息，排除之前标记为历史的消息。
    
    Args:
        last_n: 从对话末尾返回的运行次数。默认为所有运行。
        skip_role: 跳过具有此角色的消息。
        skip_status: 跳过具有此状态的消息。
        skip_history_messages: 跳过在先前运行中标记为历史的消息。
    """
```

#### 获取会话的完整聊天历史
```python
def get_chat_history(self) -> List[Message]:
    """获取会话的聊天历史"""
    messages = []
    for run in self.runs or []:
        messages.extend([msg for msg in run.messages or [] if not msg.from_history])
    return messages
```

#### 获取用户-助手消息对
```python
def get_messages_for_session(
    self,
    user_role: str = "user",
    assistant_role: Optional[List[str]] = None,
    skip_history_messages: bool = True,
) -> List[Message]:
    """
    返回会话消息列表，按用户消息和助手响应交替排列。
    """
```

### 历史管理策略
系统实现了多种历史管理策略来优化性能和成本：

#### 历史消息标记
系统使用 `from_history` 标记来区分新消息和历史消息，避免重复处理：

```python
# 在消息对象中
class Message:
    role: str
    content: str
    from_history: bool = False  # 标记是否来自历史记录
```

#### 历史截断
对于长会话，系统支持基于时间或数量的历史截断：

```python
# 获取最近5次运行的消息
recent_messages = session.get_messages_from_last_n_runs(last_n=5)
```

#### 工具调用历史
系统还提供了专门的方法来访问工具调用历史：

```python
def get_tool_calls(self, num_calls: Optional[int] = None) -> List[Dict[str, Any]]:
    """返回消息中的工具调用列表"""
```

**Section sources**
- [agent.py](file://libs/agno/agno/session/agent.py#L150-L247)
- [team.py](file://libs/agno/agno/session/team.py#L180-L266)
- [05_chat_history.py](file://cookbook/agents/session/05_chat_history.py)
- [03_chat_history.py](file://cookbook/db/03_chat_history.py)

## 会话生命周期管理

会话生命周期管理包括会话的创建、活跃期管理和过期清理等机制。

### 生命周期阶段
会话的生命周期包括以下阶段：
1. **创建阶段**：新会话被创建，分配 `session_id`
2. **活跃阶段**：会话正在被使用，持续更新
3. **非活跃阶段**：会话一段时间内无活动
4. **过期阶段**：会话超过有效期
5. **清理阶段**：过期会话被清理

### 过期策略
系统支持可配置的会话过期策略：

```python
# 配置会话过期时间
session_config = {
    "ttl": 86400,  # 24小时
    "cleanup_interval": 3600,  # 每小时检查一次
    "max_inactive_days": 30  # 最长30天不活跃
}
```

### 清理机制
会话清理机制定期执行，删除过期的会话数据：

```python
# 数据库清理操作
def cleanup_expired_sessions():
    # 获取所有过期会话
    expired_sessions = db.get_expired_sessions()
    
    # 删除过期会话
    for session in expired_sessions:
        db.delete_session(session.session_id)
    
    # 记录清理统计
    log_cleanup_stats(len(expired_sessions))
```

### 会话管理操作
系统提供了完整的会话管理API：

```python
# 创建存储实例
db = InMemoryDb()

# 获取所有会话
all_sessions = db.get_all_sessions()

# 按用户过滤会话
user_sessions = db.get_all_sessions(user_id="user123")

# 获取最近的会话
recent = db.get_recent_sessions(limit=5)

# 删除特定会话
db.delete_session("session_id")

# 清空所有会话
db.drop()
```

**Section sources**
- [agent.py](file://libs/agno/agno/session/agent.py#L25-L247)
- [team.py](file://libs/agno/agno/session/team.py#L25-L266)
- [workflow.py](file://libs/agno/agno/session/workflow.py#L10-L137)
- [README.md](file://cookbook/db/README.md#L97-L116)

## 会话数据访问与修改

会话数据的访问与修改是运行时状态管理的核心操作。

### 运行时访问
在智能体运行时，可以通过多种方式访问会话数据：

```python
# 在智能体方法中访问会话数据
def process_user_request(session_id: str, user_input: str):
    # 获取当前会话
    session = db.get_session(session_id)
    
    # 访问会话数据
    if session and session.session_data:
        user_preferences = session.session_data.get("user_preferences", {})
        conversation_stage = session.session_data.get("conversation_stage")
    
    # 访问会话历史
    chat_history = session.get_chat_history()
    
    # 访问会话摘要
    summary = session.get_session_summary()
```

### 运行时修改
会话数据可以在运行时动态修改：

```python
# 更新会话数据
def update_conversation_stage(session_id: str, new_stage: str):
    session = db.get_session(session_id)
    if session:
        if session.session_data is None:
            session.session_data = {}
        session.session_data["conversation_stage"] = new_stage
        
        # 更新时间戳
        session.updated_at = int(time.time())
        
        # 保存更新
        db.save_session(session)
```

### 并发访问处理
系统处理并发访问的策略包括：
- **乐观锁**：使用版本号或时间戳检测冲突
- **事务处理**：确保数据一致性
- **缓存机制**：减少数据库访问频率

```python
# 带冲突检测的会话更新
def safe_update_session(session_id: str, update_func):
    max_retries = 3
    for attempt in range(max_retries):
        session = db.get_session(session_id)
        if session:
            try:
                # 应用更新函数
                update_func(session)
                
                # 尝试保存，如果失败则重试
                if db.save_session(session):
                    return True
            except SessionConflictError:
                if attempt == max_retries - 1:
                    raise
                # 等待后重试
                time.sleep(0.1 * (attempt + 1))
    return False
```

**Section sources**
- [agent.py](file://libs/agno/agno/session/agent.py#L100-L149)
- [team.py](file://libs/agno/agno/session/team.py#L130-L179)
- [workflow.py](file://libs/agno/agno/session/workflow.py#L50-L100)

## 会话追踪与标识

会话追踪与标识是确保上下文一致性的关键机制。

### Session ID 机制
`session_id` 是会话系统的核心标识符，具有以下特性：
- **唯一性**：每个会话都有唯一的ID
- **持久性**：ID在会话生命周期内保持不变
- **可