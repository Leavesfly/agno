# 开发自定义工具

<cite>
**本文档中引用的文件**
- [decorator.py](file://libs/agno/agno/tools/decorator.py)
- [toolkit.py](file://libs/agno/agno/tools/toolkit.py)
- [function.py](file://libs/agno/agno/tools/function.py)
- [complex_input_types.py](file://cookbook/tools/other/complex_input_types.py)
- [custom_async_tools.py](file://cookbook/tools/custom_async_tools.py)
- [04_write_your_own_tool.py](file://cookbook/getting_started/04_write_your_own_tool.py)
- [access_dependencies_in_tool.py](file://cookbook/agents/dependencies/access_dependencies_in_tool.py)
- [test_tool_hooks.py](file://libs/agno/tests/integration/agent/test_tool_hooks.py)
- [test_functions.py](file://libs/agno/tests/unit/tools/test_functions.py)
</cite>

## 目录
1. [简介](#简介)
2. [工具装饰器基础](#工具装饰器基础)
3. [同步工具开发](#同步工具开发)
4. [异步工具开发](#异步工具开发)
5. [复杂输入类型处理](#复杂输入类型处理)
6. [工具配置选项](#工具配置选项)
7. [工具钩子系统](#工具钩子系统)
8. [工具缓存机制](#工具缓存机制)
9. [工具包管理](#工具包管理)
10. [工具依赖和会话状态](#工具依赖和会话状态)
11. [工具命名和描述最佳实践](#工具命名和描述最佳实践)
12. [故障排除指南](#故障排除指南)
13. [总结](#总结)

## 简介

Agno框架提供了强大的工具系统，允许开发者创建自定义工具来扩展智能体的能力。工具是智能体与外部世界交互的主要方式，可以执行各种操作，从简单的计算到复杂的API调用。

本指南将详细介绍如何开发、配置和管理自定义工具，涵盖从基础的同步工具到高级的异步工具，以及如何利用工具的各种特性来构建功能丰富的智能体应用。

## 工具装饰器基础

### @tool装饰器的核心功能

`@tool`装饰器是创建工具的基础，它将普通的Python函数转换为智能体可用的工具。

```python
from agno.tools.decorator import tool

@tool
def my_function():
    """这是一个简单的工具函数"""
    return "Hello from my tool!"
```

### 装饰器的多种使用方式

装饰器支持多种使用模式：

```python
# 基本装饰
@tool
def basic_tool():
    pass

# 带参数装饰
@tool(name="custom_name", description="Custom description")
def another_function():
    pass

# 异步工具
@tool
async def async_tool():
    pass
```

### 支持的配置参数

装饰器支持以下配置参数：

- `name`: 工具名称，覆盖函数名
- `description`: 工具描述，用于模型理解
- `strict`: 严格参数检查模式
- `instructions`: 使用工具的指令
- `add_instructions`: 是否添加指令到系统消息
- `show_result`: 是否显示结果
- `stop_after_tool_call`: 调用后是否停止
- `requires_confirmation`: 是否需要用户确认
- `requires_user_input`: 是否需要用户输入
- `user_input_fields`: 需要用户输入的字段列表
- `external_execution`: 是否在代理上下文外执行
- `pre_hook`: 执行前钩子
- `post_hook`: 执行后钩子
- `tool_hooks`: 工具钩子列表
- `cache_results`: 是否启用结果缓存
- `cache_dir`: 缓存目录
- `cache_ttl`: 缓存生存时间

**章节来源**
- [decorator.py](file://libs/agno/agno/tools/decorator.py#L39-L263)

## 同步工具开发

### 基础同步工具

最简单的工具是同步函数，可以直接返回结果：

```python
from agno.tools.decorator import tool

@tool
def add_numbers(a: int, b: int) -> int:
    """Add two numbers together."""
    return a + b

@tool
def greet(name: str) -> str:
    """Greet a person by name."""
    return f"Hello, {name}!"
```

### 复杂返回类型

工具可以返回各种类型的值：

```python
@tool
def create_person_dict(name: str, age: int, city: str):
    """Return a dictionary with person information."""
    return {"name": name, "age": age, "city": city}

@tool
def create_person_tuple(name: str, age: int, city: str):
    """Return a tuple with person information."""
    return (name, age, city)

@tool
def create_person_set(items: list[str]):
    """Return a set of items."""
    return set(items)
```

### 错误处理和异常

良好的工具应该包含适当的错误处理：

```python
@tool
def safe_divide(a: float, b: float) -> str:
    """Divide two numbers with error handling."""
    try:
        if b == 0:
            return "Error: Division by zero"
        return str(a / b)
    except Exception as e:
        return f"Error: {str(e)}"
```

**章节来源**
- [04_write_your_own_tool.py](file://cookbook/getting_started/04_write_your_own_tool.py#L1-L76)
- [custom_async_tools.py](file://cookbook/tools/custom_async_tools.py#L1-L89)

## 异步工具开发

### 基础异步工具

异步工具使用`async def`定义，可以执行I/O密集型操作：

```python
import asyncio
from agno.tools.decorator import tool

@tool
async def async_sleep(seconds: int) -> str:
    """Sleep for a specified number of seconds."""
    await asyncio.sleep(seconds)
    return f"Slept for {seconds} seconds"

@tool
async def async_greet(name: str) -> str:
    """Asynchronously greet a person."""
    await asyncio.sleep(0.1)  # Simulate async operation
    return f"Async Hello, {name}!"
```

### 异步生成器工具

工具还可以返回异步生成器：

```python
@tool
async def async_generator_tool(items: list[str]):
    """Return an async generator of items."""
    for item in items:
        await asyncio.sleep(0.05)  # Simulate async processing
        yield item
        yield " "
```

### 异步工具的实际应用

```python
@tool
async def fetch_weather(city: str) -> str:
    """Fetch weather information for a city."""
    # Simulate API call
    await asyncio.sleep(0.5)
    return f"Weather in {city}: Sunny, 25°C"
```

**章节来源**
- [custom_async_tools.py](file://cookbook/tools/custom_async_tools.py#L1-L89)

## 复杂输入类型处理

### Pydantic模型作为输入

使用Pydantic模型可以创建复杂的输入结构：

```python
from datetime import datetime
from enum import Enum
from typing import List, Optional
from pydantic import BaseModel, Field
from agno.tools.decorator import tool

class TaskPriority(str, Enum):
    """任务优先级枚举"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"

class Task(BaseModel):
    """任务信息模型"""
    title: str = Field(..., min_length=1, max_length=100, description="任务标题")
    description: Optional[str] = Field(None, description="详细的任务描述")
    priority: TaskPriority = Field(default=TaskPriority.MEDIUM, description="任务优先级")
    due_date: Optional[datetime] = Field(None, description="任务截止日期")
    assigned_to: Optional[str] = Field(None, description="分配给的用户")

@tool
def create_task(task_data: Task) -> str:
    """创建新任务，包含优先级和分配信息。"""
    return f"Created task '{task_data.title}' with priority {task_data.priority}"
```

### 复杂数据结构

```python
class UserProfile(BaseModel):
    """用户档案信息"""
    name: str = Field(..., description="用户的全名")
    email: str = Field(..., description="有效的电子邮件地址")
    age: int = Field(..., ge=0, le=120, description="用户年龄")
    interests: List[str] = Field(default_factory=list, description="用户兴趣列表")
    created_at: datetime = Field(default_factory=datetime.now, description="账户创建时间戳")

@tool
def create_user(user_data: UserProfile) -> str:
    """使用验证的信息创建新的用户档案。"""
    return f"Created user profile for {user_data.name} with email {user_data.email}"
```

### 枚举和常量类型

```python
class ColorMode(str, Enum):
    """颜色模式枚举"""
    LIGHT = "light"
    DARK = "dark"
    AUTO = "auto"

@tool
def set_color_mode(mode: ColorMode) -> str:
    """设置应用程序的颜色模式。"""
    return f"Color mode set to {mode.value}"
```

**章节来源**
- [complex_input_types.py](file://cookbook/tools/other/complex_input_types.py#L1-L89)

## 工具配置选项

### 基本配置

```python
@tool(
    name="calculator",
    description="Perform mathematical calculations",
    strict=True,
    show_result=True,
    stop_after_tool_call=False
)
def calculate(expression: str) -> str:
    """Evaluate a mathematical expression."""
    try:
        result = eval(expression)
        return f"Result: {result}"
    except:
        return "Error: Invalid expression"
```

### 用户交互配置

```python
@tool(
    requires_user_input=True,
    user_input_fields=["reason", "details"]
)
def approve_request(reason: str, details: str) -> str:
    """Approve a request with user input."""
    return f"Approved: {reason} - {details}"

@tool(
    requires_confirmation=True
)
def dangerous_operation() -> str:
    """Perform a potentially dangerous operation."""
    return "Dangerous operation completed"
```

### 结果控制配置

```python
@tool(
    show_result=True,
    stop_after_tool_call=True
)
def final_result(data: str) -> str:
    """Display final result and stop agent."""
    return f"Final result: {data}"
```

**章节来源**
- [decorator.py](file://libs/agno/agno/tools/decorator.py#L107-L263)

## 工具钩子系统

### 钩子的基本概念

工具钩子是在工具执行前后运行的回调函数，用于添加额外的功能。

```python
def logger_hook(function_name: str, function_call: Callable, arguments: Dict[str, Any]) -> Any:
    """记录工具调用的日志钩子"""
    print(f"HOOK PRE: Calling {function_name} with args {arguments}")
    result = function_call(**arguments)
    print(f"HOOK POST: {function_name} returned {result}")
    return result

def confirmation_hook(function_name: str, function_call: Callable, arguments: Dict[str, Any]) -> Any:
    """需要确认的钩子"""
    if function_name == "dangerous_operation":
        print("This tool requires confirmation!")
        return
    print("This tool is allowed to be called")
    return function_call(**arguments)
```

### 使用钩子装饰器

```python
@tool(pre_hook=logger_hook)
def add(a: int, b: int) -> int:
    """Add two numbers."""
    return a + b

@tool(post_hook=logger_hook)
def multiply(a: int, b: int) -> int:
    """Multiply two numbers."""
    return a * b
```

### 组合多个钩子

```python
@tool(tool_hooks=[logger_hook, confirmation_hook])
def complex_operation(data: str) -> str:
    """Perform a complex operation with logging and confirmation."""
    return f"Processed: {data}"
```

### 自定义钩子实现

```python
def audit_hook(function_name: str, function_call: Callable, arguments: Dict[str, Any]) -> Any:
    """审计钩子，记录所有工具调用"""
    audit_log = {
        "function": function_name,
        "arguments": arguments,
        "timestamp": datetime.now().isoformat()
    }
    # 在实际应用中，这里可以写入数据库或日志系统
    print(f"Audit: {audit_log}")
    return function_call(**arguments)
```

**章节来源**
- [test_tool_hooks.py](file://libs/agno/tests/integration/agent/test_tool_hooks.py#L1-L154)

## 工具缓存机制

### 启用缓存

```python
@tool(cache_results=True, cache_ttl=3600)
def expensive_computation(input_data: str) -> str:
    """Perform expensive computation that should be cached."""
    # 模拟耗时操作
    time.sleep(2)
    return f"Computed result for {input_data}"
```

### 自定义缓存目录

```python
@tool(
    cache_results=True,
    cache_dir="/path/to/custom/cache",
    cache_ttl=7200
)
def long_running_task(query: str) -> str:
    """Execute a long-running task with custom caching."""
    return f"Task result for: {query}"
```

### 缓存的工作原理

```python
# 缓存键生成逻辑
def _get_cache_key(self, entrypoint_args: Dict[str, Any], call_args: Dict[str, Any]) -> str:
    """Generate cache key from arguments."""
    combined_args = {**entrypoint_args, **call_args}
    key_string = json.dumps(combined_args, sort_keys=True)
    return hashlib.md5(key_string.encode()).hexdigest()

# 缓存文件路径
def _get_cache_file_path(self, cache_key: str) -> str:
    """Generate cache file path."""
    base_cache_dir = self.cache_dir or Path(gettempdir()) / "agno_cache"
    func_cache_dir = Path(base_cache_dir) / "functions" / self.name
    func_cache_dir.mkdir(parents=True, exist_ok=True)
    return str(func_cache_dir / f"{cache_key}.json")
```

### 缓存性能优化

```python
@tool(cache_results=True)
def api_call_with_cache(endpoint: str, params: dict) -> dict:
    """Make API call with automatic caching."""
    # 实际的API调用逻辑
    response = requests.get(endpoint, params=params)
    return response.json()
```

**章节来源**
- [function.py](file://libs/agno/agno/tools/function.py#L465-L506)
- [test_functions.py](file://libs/agno/tests/unit/tools/test_functions.py#L231-L312)

## 工具包管理

### 创建工具包

```python
from agno.tools.toolkit import Toolkit
from agno.tools.decorator import tool

@tool
def math_tool(x: int, y: int) -> str:
    """Perform math operations."""
    return f"Sum: {x+y}, Product: {x*y}"

@tool
def string_tool(text: str) -> str:
    """Manipulate strings."""
    return text.upper()

@tool
def data_tool(data: list) -> str:
    """Process data lists."""
    return f"Length: {len(data)}, Sum: {sum(data)}"

# 创建工具包
math_tools = Toolkit(
    name="math_tools",
    tools=[math_tool, string_tool, data_tool],
    instructions="Use these math tools for calculations and data manipulation."
)
```

### 工具包过滤

```python
# 只包含特定工具
filtered_tools = Toolkit(
    name="filtered_tools",
    tools=[math_tool, string_tool, data_tool],
    include_tools=["math_tool", "string_tool"]
)

# 排除特定工具
excluded_tools = Toolkit(
    name="excluded_tools",
    tools=[math_tool, string_tool, data_tool],
    exclude_tools=["data_tool"]
)
```

### 工具包配置

```python
advanced_tools = Toolkit(
    name="advanced_tools",
    tools=[math_tool, string_tool, data_tool],
    requires_confirmation_tools=["dangerous_operation"],
    external_execution_required_tools=["external_api_call"],
    stop_after_tool_call_tools=["final_result"],
    show_result_tools=["important_result"],
    cache_results=True,
    cache_ttl=1800,
    cache_dir="/custom/cache/dir"
)
```

### 工具包的使用

```python
from agno.agent import Agent

# 使用单个工具
agent = Agent(tools=[math_tool])

# 使用工具包
agent = Agent(tools=[math_tools])

# 使用多个工具和工具包
agent = Agent(tools=[math_tool, string_tool, advanced_tools])
```

**章节来源**
- [toolkit.py](file://libs/agno/agno/tools/toolkit.py#L1-L147)

## 工具依赖和会话状态

### 访问依赖项

```python
from typing import Dict, Any, Optional
from datetime import datetime

def get_current_context() -> dict:
    """获取当前上下文信息，如时间、天气等。"""
    return {
        "current_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "timezone": "PST",
        "day_of_week": datetime.now().strftime("%A"),
    }

@tool
def get_weather(location: str, dependencies: Dict[str, Any]) -> str:
    """获取天气信息，使用依赖项中的上下文。"""
    context = dependencies.get("context", {})
    current_time = context.get("current_time", "unknown")
    return f"Weather in {location} at {current_time}: Sunny"
```

### 会话状态访问

```python
@tool
def add_to_shopping_list(item: str, session_state: Dict[str, Any]) -> str:
    """向购物清单添加项目。"""
    if "shopping_list" not in session_state:
        session_state["shopping_list"] = []
    
    session_state["shopping_list"].append(item)
    return f"Added {item} to shopping list. Current list: {session_state['shopping_list']}"

@tool
def get_shopping_list(session_state: Dict[str, Any]) -> str:
    """获取购物清单。"""
    items = session_state.get("shopping_list", [])
    return f"Shopping list: {', '.join(items) if items else 'Empty'}"
```

### 动态状态管理

```python
@tool
def update_user_profile(user_id: str, updates: Dict[str, Any], session_state: Dict[str, Any]) -> str:
    """更新用户档案。"""
    if "user_profiles" not in session_state:
        session_state["user_profiles"] = {}
    
    if user_id not in session_state["user_profiles"]:
        session_state["user_profiles"][user_id] = {"id": user_id, "name": "New User"}
    
    session_state["user_profiles"][user_id].update(updates)
    return f"Updated profile for user {user_id}"
```

### 依赖注入和配置

```python
@tool
def configure_tool(config: Dict[str, Any], dependencies: Dict[str, Any]) -> str:
    """根据配置参数配置工具行为。"""
    api_key = dependencies.get("api_key")
    endpoint = config.get("endpoint", "default")
    
    return f"Configured with API key: {bool(api_key)} and endpoint: {endpoint}"
```

**章节来源**
- [access_dependencies_in_tool.py](file://cookbook/agents/dependencies/access_dependencies_in_tool.py#L1-L22)

## 工具命名和描述最佳实践

### 命名约定

```python
# 好的命名示例
@tool
def get_weather_forecast(location: str) -> str:
    """获取指定位置的天气预报。"""
    pass

@tool
def calculate_monthly_expenses(transactions: list) -> dict:
    """计算月度支出总额。"""
    pass

@tool
def send_email_notification(recipient: str, subject: str, body: str) -> str:
    """发送电子邮件通知。"""
    pass

# 避免的命名
@tool
def func1(param: str) -> str:
    """这个命名不够清晰。"""
    pass

@tool
def process_data(data: dict) -> str:
    """过于模糊的描述。"""
    pass
```

### 描述编写技巧

```python
@tool
def complex_business_logic(
    param1: str, 
    param2: int, 
    param3: Optional[bool] = None
) -> str:
    """
    执行复杂的业务逻辑处理。
    
    参数:
        param1 (str): 第一个必需参数，描述其用途
        param2 (int): 第二个必需参数，描述其范围和限制
        param3 (Optional[bool]): 第三个可选参数，默认为None
        
    返回:
        str: 处理结果的字符串表示
        
    示例:
        >>> complex_business_logic("input", 42)
        "Processing complete"
        
    注意事项:
        - param2必须大于0且小于1000
        - 如果param3为True，则启用调试模式
    """
    pass
```

### 文档字符串格式化

```python
@tool
def formatted_documentation(
    user_input: str,
    options: Optional[dict] = None
) -> str:
    """
    格式化用户输入并应用选项。
    
    :param user_input: 用户提供的原始输入
    :type user_input: str
    :param options: 可选的格式化选项
    :type options: dict, optional
    :return: 格式化后的结果
    :rtype: str
    :raises ValueError: 当输入无效时抛出
    :example:
        >>> formatted_documentation("hello world")
        "HELLO WORLD"
        >>> formatted_documentation("hello world", {"uppercase": False})
        "hello world"
    """
    pass
```

### 多语言支持

```python
@tool
def internationalized_tool(
    text: str,
    language: str = "en"
) -> str:
    """
    国际化文本处理。
    
    Args:
        text (str): 要处理的文本
        language (str): 目标语言代码，默认为'en'
        
    Returns:
        str: 处理后的文本
        
    Supported Languages:
        - en: English
        - es: Spanish
        - fr: French
        - de: German
        - zh: Chinese
        
    Raises:
        ValueError: 当不支持的语言代码时
    """
    supported_languages = ["en", "es", "fr", "de", "zh"]
    if language not in supported_languages:
        raise ValueError(f"Unsupported language: {language}")
    
    # 处理逻辑...
    return f"Processed '{text}' in {language}"
```

## 故障排除指南

### 常见问题和解决方案

#### 1. 工具无法被识别

```python
# 问题：工具没有正确注册
@tool
def my_tool():  # 缺少装饰器
    pass

# 解决方案：确保使用@tool装饰器
@tool
def my_tool():
    pass
```

#### 2. 参数类型不匹配

```python
# 问题：参数类型不正确
@tool
def bad_tool(param: int):  # 参数应该是str而不是int
    pass

# 解决方案：使用正确的类型注解
@tool
def good_tool(param: str):
    pass
```

#### 3. 异步工具问题

```python
# 问题：异步工具没有正确处理
@tool
async def async_tool():
    return "result"

# 解决方案：确保正确使用async/await
@tool
async def async_tool():
    await asyncio.sleep(1)
    return "result"
```

#### 4. 缓存问题

```python
# 问题：缓存不工作
@tool(cache_results=True)
def uncached_tool(data: str):
    return f"Result: {data}"

# 解决方案：确保函数有确定性
@tool(cache_results=True)
def cached_tool(data: str):
    # 这个函数每次都会产生相同的结果
    return f"Result: {data}"
```

### 调试技巧

```python
import logging
from agno.utils.log import logger

# 启用详细日志
logging.basicConfig(level=logging.DEBUG)

@tool
def debuggable_tool(input_data: str) -> str:
    """带有调试信息的工具。"""
    logger.debug(f"Tool received input: {input_data}")
    
    try:
        result = process_data(input_data)
        logger.debug(f"Tool processed successfully: {result}")
        return result
    except Exception as e:
        logger.error(f"Tool failed with error: {e}")
        raise
```

### 性能监控

```python
import time
from functools import wraps

def monitor_performance(func):
    """监控工具执行性能的装饰器。"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        
        print(f"Tool {func.__name__} took {end_time - start_time:.2f} seconds")
        return result
    return wrapper

@tool
@monitor_performance
def performance_tool(data: str) -> str:
    """监控性能的工具。"""
    time.sleep(0.1)  # 模拟处理时间
    return f"Processed: {data}"
```

**章节来源**
- [test_functions.py](file://libs/agno/tests/unit/tools/test_functions.py#L231-L312)

## 总结

开发自定义工具是扩展Agno智能体能力的关键。通过本指南，我们涵盖了：

1. **基础工具开发**：使用`@tool`装饰器创建同步和异步工具
2. **复杂输入处理**：使用Pydantic模型和枚举类型
3. **工具配置**：利用各种配置选项控制工具行为
4. **工具钩子**：添加预处理和后处理功能
5. **缓存机制**：提高工具性能和效率
6. **工具包管理**：组织和管理多个工具
7. **依赖和状态**：访问智能体上下文和会话状态
8. **最佳实践**：遵循命名和文档规范

通过合理使用这些技术和最佳实践，您可以创建强大、可靠且易于维护的自定义工具，从而显著增强智能体的功能和表现。

记住，好的工具应该：
- 具有清晰、描述性的名称和文档
- 提供适当的错误处理
- 支持异步操作（如果需要）
- 利用缓存来提高性能
- 通过钩子系统添加额外功能
- 正确处理依赖关系和状态

随着您对工具系统的深入了解，您将能够构建更加复杂和功能丰富的智能体应用。